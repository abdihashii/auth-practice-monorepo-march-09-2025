import { OAuth2Client } from 'google-auth-library';

import type { ProviderUserProfile } from '@/lib/types';

import env from '@/env';

import type { IOAuthProvider } from './oauth-provider';

const GOOGLE_CLIENT_ID = env.GOOGLE_CLIENT_ID!;
const GOOGLE_CLIENT_SECRET = env.GOOGLE_CLIENT_SECRET!;
const GOOGLE_REDIRECT_URI = env.GOOGLE_REDIRECT_URI!;

/**
 * Implements the `IOAuthProvider` interface for Google OAuth 2.0
 * authentication. Handles the generation of authorization URLs and processes
 * the callback from Google to obtain user profile information.
 */
export class GoogleOAuthAdapter implements IOAuthProvider {
  /**
   * Identifies the authentication provider as 'google'.
   * Required by the `IOAuthProvider` interface.
   */
  readonly providerName = 'google';

  /**
   * The underlying Google OAuth 2.0 client instance used for authentication.
   * Initialized in the constructor with credentials from environment variables.
   */
  private oauth2Client: OAuth2Client;

  /**
   * Initialize the Google OAuth Provider instance with a new OAuth2 client
   * using the client ID, client secret, and redirect URI from the environment
   * variables.
   */
  constructor() {
    this.oauth2Client = new OAuth2Client(
      GOOGLE_CLIENT_ID,
      GOOGLE_CLIENT_SECRET,
      GOOGLE_REDIRECT_URI,
    );
  }

  /**
   * Get the authorization URL for Google OAuth that the server will redirect
   * the user to.
   *
   * @param state - The state parameter for CSRF protection. In our case, this
   * is a random UUID generated by the server.
   * @param scopes - Optional: specify custom scopes from the function caller or
   * use the default scopes defined directly in this function.
   * @returns The authorization URL for Google OAuth
   */
  getAuthorizationUrl(state: string, scopes?: string[]): string {
    // OAuth 2.0 scopes are permission strings that let developers specify and
    // limit precisely what level of access their application can request to
    // Google APIsâ€”enabling fine-grained, user-consented security boundaries
    // and fulfilling Google's sensitive-scope verification requirements.
    // Learn more about scopes here:
    // https://developers.google.com/identity/protocols/oauth2/scopes
    const defaultScopes = [
      // See user's personal info, including any personal info they've made publicly available
      'https://www.googleapis.com/auth/userinfo.profile',
      // Sees user's primary Google Account email address
      'https://www.googleapis.com/auth/userinfo.email',
      // Required for ID token and is associated with the user's personal info on Google
      'openid',
    ];

    const authUrl = this.oauth2Client.generateAuthUrl({
      access_type: 'offline', // Use 'offline' if you need refresh tokens
      scope: scopes || defaultScopes, // Optional: specify custom scopes from the function caller
      state, // CSRF protection
      prompt: 'consent', // Optional: forces consent screen even if previously approved
    });
    return authUrl;
  }

  /**
   * Handles the callback from Google after user authentication.
   * Verifies the state parameter for CSRF protection, exchanges the authorization
   * code for tokens, verifies the ID token, and extracts user profile information.
   *
   * @param code - The authorization code received from Google's redirect.
   * @param state - The state parameter received from Google's redirect.
   * @param storedState - The state parameter previously stored in the user's session.
   * @returns A Promise that resolves with the standardized user profile information.
   * @throws {Error} If the state parameter is invalid (CSRF attempt).
   * @throws {Error} If the ID token is missing or invalid.
   * @throws {Error} If the ID token payload is invalid or missing required fields.
   * @throws {Error} If the authorization code is invalid or expired.
   * @throws {Error} For general failures during the token exchange or verification process.
   */
  async handleCallback(code: string, state: string, storedState: string): Promise<ProviderUserProfile> {
    if (state !== storedState) {
      throw new Error('Invalid state parameter (CSRF detected)');
    }

    try {
      // Exchange the authorization code for tokens
      const { tokens } = await this.oauth2Client.getToken(code);

      if (!tokens.id_token) {
        throw new Error('ID token not received from Google');
      }

      // Verify the ID token and get the payload
      const ticket = await this.oauth2Client.verifyIdToken({
        idToken: tokens.id_token,
        audience: GOOGLE_CLIENT_ID, // Specify the CLIENT_ID of the app that accesses the backend
      });

      const payload = ticket.getPayload();

      if (!payload || !payload.sub || !payload.email) {
        throw new Error('Invalid ID token payload received from Google');
      }

      // Construct the standardized user profile
      const userProfile: ProviderUserProfile = {
        provider: this.providerName,
        providerId: payload.sub,
        email: payload.email,
        name: payload.name ?? null,
        picture: payload.picture ?? null,
      };

      return userProfile;
    } catch (error) {
      console.error('Error handling Google callback:', error);
      // Provide a more specific error message if possible
      if (error instanceof Error && error.message.includes('invalid_grant')) {
        throw new Error('Invalid or expired authorization code.');
      }
      throw new Error('Failed to process Google authentication.');
    }
  }
}
